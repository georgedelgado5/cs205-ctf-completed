CTF_CH07.01_work
************************************************************************************************************
************************************************************************************************************
Ch07_01_GdbIntro

1. Ran "./Ch07_01_GdbIntro"

2. Message: 
 "In this level, library tracing has been made difficult so that you can learn
  to use gdb.  There are multiple strcmp() calls in main().  Two of them are
  bogus and one of them is the real check.  You will need to set breakpoints at
  each call to strcmp() in main.  To do so, load the program in gdb and do
  a "layout split" to obtain multiple windows.  Then type "layout asm" to
  get the assembly view.  Type "focus asm" to allow the arrow keys to scroll
  up and down and find the 3 calls to strcmp().  Set a breakpoint at the
  address of each call by typing something similar to "break *main+150" or
  "break 0x4007dd".  The key to the level is that the bogus strcmp() calls
  will be called multiple times, while the real call that checks the password
  is called only once.  So, run the program and enter the password.  Check
  which breakpoint is hit when the debugger is interrupted before continuing
  by typing "c".  If a breakpoint is hit more than once, delete it using the
  command "del <breakpoint #>".  When the program ends type "info br" to
  identify the breakpoint that indicates where the real strcmp() is called.
  
  Now, with real strcmp() identified, you will be examining the parameters to
  this call to discover the real password.  strcmp() is passed two pointers
  to strings.  In the calling convention of x86-64, parameters are passed in
  registers %rdi, %rsi, %rdx, %rcx, %r8, and %r9 (Diane's Silk Dress Cost $89).
  With only two parameters, the pointers to the strings are stored in %rdi and
  %rsi.  Run the program again and enter a password.  When the program breaks,
  examine the memory pointed to by both %rdi and %rsi.  To do so, use the
  examine command with the string option by typing "x /s $rdi" and
  "x /s $rsi" to find the password.

3. Ran "gdb ./Ch07_01_GdbIntro"
	- type "lay asm" --> to be in asm view
	- type "focus asm" --> not necessary; lets you move through asm with arrow keys

4. Find in main section where strcmp is called
	There are 3 "call" instructions that call strcmp

5. Set breakpoint at each of the 3 calls
	- Example use "*main+171" to set a breakpoint at that line
	- IMPORTANT: include the asterisk (*) before "main" to ensure running debugger cycles through

6. Type and enter "run"
	
7. Use "c" for continue

8. Debugger will either loop through many times or once.
	- If runs more than once delete breakpoint

9. To delete breakpoint
	- "info br" displays all breakpoints and will displays number of times cycled through

10. Continue until you find strcmp that only runs once

11. Run program again so that breakpoint is right at the correct breakpoint

12. Type "x /s $rdi" to show the password you entered

13. Type "x /s $rsi" to show actual password
	"do8FUZAc"

14. Solved

************************************************************************************************************
Ch07_01GdbRegs

1. Ran "./Ch07_01_GdbRegs"

2. Message:
"When a function returns an integer value of any size (char, short, int,
 or long), it places the value into register a (%al, %ax, %eax, or %rax).
 In this level, use gdb to locate the function retval_in_rax().  At the
 end of the function, set a breakpoint at the retq instruction using a
 command similar to "break *0x400300" or "break *retval_in_rax+30".
 Run the program.  The password is the return value from the function
 retval_in_rax().  Use the print command to reveal it (e.g. p $rax)
"

NOTE: It is useful to have to terminals open.

3. At terminal run "gdb -tui ./Ch07_01_GdbRegs" or "gdb ./Ch07_01_GdbRegs"
	- NOTE: 'tui' just opens the starts the layout format

4. When in gdb, type "lay asm". Then type "focus asm"

5. Find the function for retval_in_rax
	- There will be multiple lines that have show "<retval_in_val>

6. Set a breakpoint at the retval_in_rex function with the command that uses 'ret'
	- use: "b *retval_in_rax+##" or "break *retval_in_rax##"
	- NOTE: Where the '##' appear in the previous command, use the number that appears on your screen

7. Set a breakpoint at '*0x400300"
	- NOTE: This is given in the message. This might be a different address for you.

NOTE: The order in which you set the breakpoints does not matter

8. After setting the breakpoints in gdb, run the program
	- you can use "run" or "r"

9. You will prompted with the message again and asked to enter a password
	- Enter any value or keys - it doesn't matter

10. After entering password - and still in gdb - type "p $rax"
	- This command was given in the message
	- In my case: "$1 = 1906984398"

11. The password is (in my case): 1906984398

12. Solved!
************************************************************************************************************
Ch07_02_AsciiInstr

1. Ran "./Ch07_02_AsciiInstr"

2. Message:
"In this level, you will need to use your knowledge of ASCII encoding to find
 the password. While you can solve this level in many ways, try using
 "objdump -d" or the disassembler in gdb.
"

3. There are two methods to solving this problem.
	1. Manually decode hex to ascii characters 
	2. Use gdb to directly print password

4. Manual decoding method:
	1. Inspect the assembly code with either "objdump -d ./Ch07_02_AsciiInstr" or use gdb with "gdb ./Ch07_02_AsciiInstr"
	
	2. Our focus is on 'main' - find that section of code and inspect the beginning

	NOTE: The assembler is using x64 bit registers. I investigated and found that the registers naming conventions are not vastly different
		- eax ~ rax
		- ebp ~ rbp → stack frame
		- esp ~ rsp → stack

	3. In main, immediately after the FIRST 'xor' command, we see ascii characters being moved onto the stack frame via the 'movb' and 'movl' commands. 
		Decode each hex to ascii character in order
		- 0x6e : n
		- 0x33 : 3
		- 0x55 : U (uppercase)
		- 0x61 : a
		- 0x65 : e
		- 0x64 : d
		- 0x50 : P (uppercase)
		- 0x44 : D (uppercase)

	4. Password : n3UaedPD
	
	5. Solved!

5. gdb method:
	1. Inspect the assembly code with "gdb ./Ch07_02_AsciiInstr"

	2. In main, immediately after the FIRST 'xor' command, we see ascii characters being moved onto the stack frame via the 'movb' and 'movl' commands.
		
		NOTE: There are many 'movb' commands followed by one 'movl' command. 
			- movb = move byte = 1-byte
			- movl = move long = 4-bytes
		      My best guess is that since this is a 64-bit register, the password is stored in 32-bits and the other 32-bits (eax) are set to zero.


	3. Set a breakpoint at any point after the first 'movl' command. For me that was "b *main+62"

	4. Run the code in gdb using the 'r' command

	5. Gdb will stop at the breakpoint. At this point rbp contains the each fragment of the ascii password. To get the full password we use the command "x /s $rsp"
		NOTE: We use 'rsp' instead of rbp because as with all our functions, we set the stack frame into the stack (rsp)

		NOTE: The command "x /s $rsp" was shown in "./Ch07_01_GdbIntro" message

	6. The full password will be displayed : "n3UaedPD"

	7. Solved!

6. Solved using both methods!
************************************************************************************************************
Ch07_01_GdbPX

1. Ran "./Ch07_01_GdbPX"

2. Message (very long): 
"The goal of this level is to practice using the p (print) and x (examine
 memory) commands to discover the address of a string and to examine the
 memory locations that it is stored.  The password consists of 6 parts
 separated by spaces with any hexadecimal parts input without the leading
 "0x".  Using gdb in TUI mode, type "layout asm", then scroll to find
 where the check_pass function is called in main.  A single argument is
 passed to this function that is a pointer to a string. Set a breakpoint
 right before the check_pass call (e.g. if call is at main+32, then in gdb
 type "break *main+32").
 
 Run the program.  When it breaks, refresh the screen via "Ctrl-L", then
 print the contents of the register that contains the pointer (i.e. the
 address of the string).  For x86-64, the register is %rdi. For IA32, it is
 the register pushed onto the stack right before the call.  Print the
 register in hex (i.e. p /x $rdi or p /x $eax). This is the first part of
 the password.
 
 For subsequent parts of the password, we will use the examine command.
 The general format for the x command is: x /<n><f><u> where n is the number
 of units, f is format, and u is the size of the unit.
 
 The second part of the password is the 8 character string stored at the
 address. To print that, use the examine command with the string format
 (i.e. x /s 0x<address_in_register> or x /s $<register>).
 
 For the third part of the password, examine the same memory location, but
 return the results as an 8-byte long integer in hexadecimal via the giant
 specifier (i.e. x /xg ).
 
 Then, examine the memory location, but return the results as 2 4-byte
 hexadecimal values via the word specifier (i.e. x /2xw ).  The fourth part
 is the high 4-bytes.
 
 Then, examine the memory as 8 1-byte hexadecimal values via the byte
 specifier (i.e. x /8xb ).  The fifth part is the fifth byte of the string
 in hex.
 
 Finally, examine the memory as 8 1-byte decimals via the decimal specifier
 (i.e. x /8db ). The sixth part is the sixth byte of the string in decimal.
 Note that you could also print it directly by adding 5 to the register
 then examining (i.e. x /8db $rdi+5)
 "

2. Run "gdb -tui ./Ch07_01_GdbPX"

3. In gdb run the 'layout asm' or 'lay asm' command → This sets the display to show the assembly (asm) code

4. Find the first "check_pass" call function in main and set a break point using "break *main+30" or "b *main+30"
	NOTE : I used "...main+30" Your main line code at function call could be some other value such as "...main+45"

5. Run the program using the 'run' or 'r' command. Then clear the terminal using 'ctrl + l' (the letter "L"). 

6. Print the address of the 'rdi' register using "p /x $rdi"
	
	This is your first password of six → "0x402007" (this address is unique to me. Yours will be different)

7. Print the character string stored at that address (rdi) using "x /s $rdi"
	
	This is your second password of six → "YWEzYjJm" (Unique to me. Yours will be different)

8. Print the same memory location but as an 8-byte long integer in hexadecimal using "x /xg $rdi"
	
	This is your third password of six → "0x6d4a6a597a455759"

9. Print the memory location as 2 4-byte hexadecimal values using "x /2xw $rdi"
	
	0x7a455759	0x6d4a6a59
	
	The fourth part is the high 4-byte address → 0x6d4a6a59

10. Print the memory as 8 1-byte hexadecimal values using "x /8xb $rdi"
	
	0x59	0x57	0x45	0x7a	0x59	0x6a	0x4a	0x6d

	The fifth part is the fifth byte of the string in hex → 0x59

11. Print the memory as 8 1-byte decimals using "x /8db $rdi"
	
	89	87	69	122	89	106	74	109

	The sixth part is the sixth byte of the string in decimal → 106

12. All six passwords :

	0x402007 YWEzYjJm 0x6d4a6a597a455759 0x6d4a6a59 0x59 106

13. Solved!

************************************************************************************************************
Ch07_01_Gdb_Setmem

1. Ran "./Ch07_01_GdbSetmem"

2. Message:
"In GDB, one can overwrite a memory address while at a breakpoint using
 the command "set {dt} 0xaddress=value" where dt is the data type,
 address is the memory location in hex, and value is what you wish to
 write to the address.  In this program, there is a comparison involving
 an integer that, if satisfied, will print the password.  Changing the
 integer to the appropriate value will then cause the password to be
 printed. You can then use this password to solve the level outside of
 the debugger.  Some other GDB commands that might help you include:
    break *main+30    (sets a breakpoint at this location in main)
    p /x $rbp-0x24    (prints the hexadecimal address of -0x24(%%rbp)
    x /xw $rbp-0x24   (prints the integer at address -0x24(%%rbp)
 "

3. Run "gdb ./Ch07_01_GdbSetmem"

4. Type "layout asm" or "lay asm" to open assembly view
	NOTE: Helpful to use "set disassembly-flavor intel" while in gdb to read in intel syntax
	
5. Set a breakpoint at the first compare command using "b *main+101" → Your line number may be different

6. Set a breakpoint at the top of the print password function using "b *print_pswd"

7. Run the program in gdb using 'r' or "run"

8. When prompted to enter a password, you can enter whatever you like

9. After typing password, change the value being compared. You will find that we can only change one value
	
	9.a Type "set {int} ($rbp-0x1c)=0xd0" → Your rbp address might be differet and the other value to compare (0xd0 in my case) might be different. Use your values.

	9.b Type "continue" or 'c'

10. gdb will stop at the first print_pswd breakpoint. Set another breakpoint after the inverse hash function call using "b *print_pswd+24" → your line number might be different

11. Continue to the breakpoint you set by typing "continue" or 'c'

12. At this point you can type "info registers" or "i r" or "i r $rax"
	
	NOTE: The inverse hash function returns the password into rax. Like for 32-bit eax is used for returns, for 64-bits, rax is used to return values.

	NOTE: using "i r" command prints the address on the left and value at that address on the right. 

	NOTE: Notice how the value is negative. This means that this is an unsigned value and needs to be printed with the correct format.

13. To print the unsigned value use "p /u $rax"

	NOTE: 'p' is the print command; '/u' is the unsigned format specifier; and $rax is the register we want to use.

14. 15197980642638090065

15. Solved!
	

************************************************************************************************************



