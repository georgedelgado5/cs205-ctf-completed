Ch04_work
************************************************************************************************************
************************************************************************************************************
Ch04_00_Showkey:

1. Ran "./Ch04\_00\_Showkey"
2. Message:
   In this level, you will be converting from ASCII to hexadecimal, decimal,
   and octal.  Most often, students look up a table online and directly
   convert. An easier way is to use a tool such as "showkey".  In this
   level, use "showkey -a" to discover the representations of
   an ASCII string.  You will be given the password represented as a string,
   but you will need to supply 3 arguments which represent the password in
   its hexadecimal, decimal, and octal codes.  For hexadecimal, use 2 digits.
   For decimal and octal, use 3 digits and zero pad on the left for codes
   below 100.  For example, a password string of ab% would yield a password
   of 616225 097098037 141142045

3. Used "man showkey" to learn about showkey
	-- "-showkey -a" is used to show the ASCII, OCTAL, and HEXADECIMAL values of every key typed in (use ctrl + D to quit)

4. Ran "-showkey -a" on "D", "O", "U", and lowercase zee "z"
	-- D: D        68 0104 0x44
	-- O: O        79 0117 0x4f
	-- U: U        85 0125 0x55
	-- z: z       122 0172 0x7a

5. Re-ran "./Ch04\_00\_Showkey"
	-- The executable file takes in 3 arguments in the following order it asks is HEX, ASCII, OCTAL
	-- HEX : use 2 digits
	-- ASCII/OCTAL : use 3 digits
	-- Type in hex value, enter, type in ascii value, enter, type in octal value, enter

6. 444f557a 068079085122 104117125172

7. Solved!

*****************************************************************************************************************
Ch04_03_TwosComplement

1. Ran "./Ch04_03_TwosComplement

2. Message: 
 "Many computer applications need a proper representation of negative
  numbers.  The most common of these is the two's-complement form.
  The form can be represented as a vector of length w bits:
     x = [x_w-1, x_w-2, ..., x_0].
  The most significant bit x_w-1 has a value of -2^(w-1) while the rest
  of the bits are positive powers of 2.  Thus if the most significant bit
  is set, the number is negative, while if it is cleared, it is positive.
  Learning to work with two's-complement is important due to overflow issues
  and the improper casting between unsigned and signed values.  In this
  level, the passcode is encoded as a 12-bit two's complement number.  Find
  its signed decimal value to complete the level."

		111010100010

3. Open Calculator --> programmer option
	
4. Use word option and typed in binary number given. 
	NOTE: word is 16 bits wide. To account for 12-bits get the value of the 13th bit. This applies to any number of bits. Example 16-bits, get 17th bit,
		The value for (0001 0000 0000 0000) is equal to 4096
	Then subtract the 12-bit value given in the problem from the 4096 decimal value
		The value for (1110 1010 0010) is 3746

5. The decimal result of 350 is our starting point.
	4096 - 3746 = 350

6. Now process two's complement as normal

7. Use NOT operation on decimal 350 value -> one's complement
	NOT(350) = -351

8. Add one to that value to get two's complement
	-350 + 1 = -350

8. Solved!
*****************************************************************************************************************
Ch_04_05_IntOverflow

1. Ran "./Ch04_05_IntOverflow"

2. Message:
 "Each unsigned integer data type has a maximum limit that will wraparound
 to 0 if exceeded.  In this level, you are given an unsigned char, an
 unsigned short, and an unsigned int in hexadecimal.  The password is
 the corresponding 3 positive numbers (in decimal) that can be added
 to each to overflow the data type to produce a sum of 0.

   unsigned char addc, c=0x12;
   unsigned short adds, s=0x822;
   unsigned int addi, i=0xdd2f1c4f;
   ...
   printf("Your numbers are: %hhx %hx %x\n", c, s, i);
   ...
   printf("Enter the password: ");
   scanf("%hhu %hu %u", &addc, &adds, &addi);
   c += addc;   s += adds;   i += addi;  ...
   if (!c && !s && !i)
     printf("Good Job.");

 Your numbers are: 12 822 dd2f1c4f

3. Open Calculator --> programmer option

4. Set the calculator to QWORD or 64-bit

5. Determine the unsigned max value:
	- 8-bit unsigned max is 100 = (FF + 1)
	- 16-bit unsigned max is 10000 = (FFFFF + 1)
	- 32-bit unsigned max is 100000000 = (FFFFFFFF + 1)

6a. Subtract the value unsigned max value and the original value
	- [ 0x100 - 0x12] = 0xEE = 238 in decimal
	- [ 0x10000 - 0x822 ] = 0xF7DE = 63454 in decimal
	- [ 0x100000000 - 0xDD2F1C4F ] = 584115121 in decimal

OR

6b. Subtract the value unsigned max value and the original value
	- [ 0xFF - 0x12] = 0xED = 237 in decimal + 1 = 238 in decimal
	- [ 0xFFFF - 0x822 ] = 0xF7DD = 63453 in decimal + 1 = 63454 in decimal
	- [ 0xFFFFFFFF - 0xDD2F1C4F ] = 0x22D0E3B0 = 584115120 in decimal + 1 = 584115121 in decimal

7. Answer: 238 63454 584115121

8. Solved!


*****************************************************************************************************************
Ch04_06_XorInt

1. Ran "./Ch04_06_XorInt"

2. Message:
 "Try out my brand-new XOR cipher.  Enter a 4-byte hexadecimal number
 (e.g. 4f91853a) and see how my cipher encrypts it.  While it is highly
 unlikely you will be able to guess the key I am using out of the over
 4 billion possible values, rather than crash, the program will instead
 print "Good Job." and exit if you happen to input the key I'm using
 We have heard some rumors about XOR being vulnerable to chosen plaintext
 attacks. Maybe if we find something on Google, we'll switch to another.
 Since I know you are well-versed in debuggers and could probably pull
 the key out of memory, I have conveniently disabled debugging for you."

3. This took me a while to figure out and help from Jesse Chaney. Basically using the XOR truth table we know:

              T           F            Result
	------------|--------------|----------------
              0     |       0      |       0    
                    |              |    
              0     |       1      |       1 (or other key)   
                    |              |    
              1     |       0      |       1 (or other key)
                    |              |    
              1     |       1      |       0                    

 From this we know that when one value equals zero (0), the other will be one (1) or some "key" that can be used as a placeholder. 

4. Knowing that the XOR truth table will return the key/value when one value is zero (0), we can type the integer value zero (0) as our key and we will get our key returned. 

5. The key returned is : 466cf50c

6. Type in the returned key

7. Solved

*****************************************************************************************************************
Ch04_07_Endian

1. Ran "./Ch04_07_Endian

2. Message:
"Endianness refers to the convention used to interpret bytes in a data word.
 Little-endian systems store the Least significant byte in the Lowest
 address (LLL) while big-endian systems store the most significant byte
 of a word in the lowest address. For example, if we had the quad word
 0x1234567890ABCDEF, big endian systems would store 0x12 in the lowest
 address while little endian systems would store 0xEF in the lowest address.
 Similarly, if we had the double word 0x01020304, big endian systems
 would store the 0x01 in the lowest address while little endian systems
 would store the 0x04 in the lowest address.  This level contains the
 following code (where xxxxxxxx is substituted for the level password)
    char password[9]="xxxxxxxx";
    unsigned int * ip;
    ip = (unsigned int *) &password;
    printf("%08x : %08x\n", *ip, *(ip+1));
 Use your knowledge of ASCII encoding and endianness to find the password

 Output of above C code
 63674a72 : 5a6e4b5a       "

3. The output shown displays the password as hex values in reverse order because it is in (little or big?)

4. I wrote the output in reverse:
	724a6763 : 5a4b6e5a

5. Using man ascii I converted the hex values into their characters in their new formatted order
	- 72 : r
	- 4a : J (uppercase)
	- 67 : g
	- 63 : c
	- 5a : Z (uppercase)
	- 4b : K (uppercase)
	- 6e : n
	- 5a : Z (uppercase)

6. Together the new password is : rJgcZKnZ
 
7. Solved
*****************************************************************************************************************
Ch_04_08_FloatConvert

1. Ran "./Ch04_08_FloatConvert"

2. Message:
"In this level, you will practice correctly converting a single-precision
 IEEE floating point number to its machine representation and vice-versa.
 The password to unlock the level is the result of these two conversions
 and will be read in using:   scanf("%x %f");
 For your inconvenience, we have turned off debugging.

 Give the machine representation of the floating point number  21084.0 (in hex)
 followed by the floating point value represented by the hex pattern 47718700"

3. For "single-precision" 32-bits total - from IEEE Arithmetic pdf slides
	- 1 sign bit
	- 8 exp bits
	- 23 frac bits

  	| s |  exp  |    frac    |

	- s is sign bit
	- exp field is an encoding to derive E (exponent)
	- frac field is an encoding to derive M (mantissa)

4. For normalized:
	- E = (exp - bias)
	- M = 1 + frac

5. Bias is 2^(k - 1) - 1 = 2^(8 - 1) - 1 = 7

6. To get value:
	- V = (-1)^s * M * 2^E
 
7. 




